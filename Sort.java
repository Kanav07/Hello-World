package algorithmsBasics;import java.sql.Time;import java.util.*;public class Sort {    public static int LARGE_VALUE = 99999;    public static class SortTimes{        private String sortName;        private Long sortTime;        public String getSortName() {            return sortName;        }        public void setSortName(String sortName) {            this.sortName = sortName;        }        public Long getSortTime() {            return sortTime;        }        public void setSortTime(Long sortTime) {            this.sortTime = sortTime;        }        public SortTimes(String sortName, Long sortTime) {            this.sortName = sortName;            this.sortTime = sortTime;        }        @Override        public String toString() {            return                    "sortName='" + sortName + '\'' +                    ",\tsortTime=" + sortTime +                    '}';        }    }    public static class SortTimesCompare implements Comparator<SortTimes>{        @Override        public int compare(SortTimes s1, SortTimes s2) {            if (s1.getSortTime() < s2.getSortTime()) {                return -1;            }else{                    return 1;                }            }        }    public static void main(String[] args) {        long startTime, endTime;        ArrayList<SortTimes> sortTimes = new ArrayList<SortTimes>();        int[] list = unSortList();        printList(list);        System.out.println();        int listLength = list.length;        System.out.println("**************\tSELECTION SORT\t**************");        startTime = System.nanoTime();        list = selectionSortExtraMemory(list, listLength);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("selectionSortExtraMemory", endTime - startTime));        //Re-initialise list with unsorted list. Comment the next line out to input a sorted list into the next algorithm        list = unSortList();        startTime = System.nanoTime();        list = selectionSortWithoutExtraMemory(list, listLength);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("selectionSortWithoutExtraMemory", endTime - startTime));        //Re-initialise list with unsorted list. Comment the next line out to input a sorted list into the next algorithm        list = unSortList();        System.out.println("\n**************\tBUBBLE SORT\t**************");        startTime = System.nanoTime();        list = bubbleSort(list, listLength);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("bubbleSort", endTime - startTime));        //Re-initialise list with unsorted list. Comment the next line out to input a sorted list into the next algorithm        list = unSortList();        System.out.println("\n**************\tINSERTION SORT\t**************");        startTime = System.nanoTime();        list = insertionSort(list, listLength);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("insertionSort", endTime - startTime));        //Re-initialise list with unsorted list. Comment the next line out to input a sorted list into the next algorithm        list = unSortList();        System.out.println("\n**************\tMERGE SORT\t**************");        startTime = System.nanoTime();        mergeSort(list, listLength);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("mergeSort", endTime - startTime));        //Re-initialise list with unsorted list. Comment the next line out to input a sorted list into the next algorithm        list = unSortList();        System.out.println("\n**************\tQUICK SORT\t**************");        startTime = System.nanoTime();        quickSort(list, 0,listLength-1);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("quickSort", endTime - startTime));        list = unSortList();        System.out.println("\n**************\tQUICK SORT\t**************");        startTime = System.nanoTime();        randomisedQuickSort(list, 0,listLength-1);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("randomisedQuickSort", endTime - startTime));        list = unSortList();        System.out.println("\n**************\tQUICK SORT\t**************");        startTime = System.nanoTime();        quickSort2(list, 0,listLength-1);        endTime = System.nanoTime();        printList(list);        System.out.println("\nTime taken : " + (endTime - startTime) + " nanoseconds");        sortTimes.add(new SortTimes("quickSort2", endTime - startTime));        System.out.println();        Collections.sort(sortTimes,new SortTimesCompare());        for (SortTimes s : sortTimes) {            System.out.println(s);        }            }    public static int[] unSortList() {        //list of 10 integers between 0 and 100        int[] temp1 = {9, 8, 3, 6, 2, 7, 1, 0, 17, 4};        //list of 40 integers between 0 and 100        int[] temp2 = {9, 8, 3, 6, 2, 7, 1, 0, 11, 13, 16, 23, 14, 10, 42,                4, 12, 99, 78, 34, 20, 92, 84, 67, 64, 39, 61, 80, 22, 93,                19, 70, 62, 9, 88, 44, 30, 94, 17, 43};        //list of 99 integers between 0 and 100        int[] temp3 = {75, 78, 90, 12, 45, 32, 73, 55, 59, 7, 89, 31, 79, 35, 56, 39,                5, 15, 42, 53, 80, 4, 19, 14, 29, 86, 10, 98, 84, 34, 38, 17,                69, 93, 28, 88, 97, 74, 43, 57, 65, 87, 27, 23, 21, 33, 99, 1,                77, 82, 46, 51, 50, 100, 49, 96, 3, 91, 66, 58, 48, 26, 72, 92,                30, 68, 70, 20, 24, 62, 16, 71, 64, 47, 44, 25, 36, 67, 2, 54,                76, 11, 85, 18, 60, 8, 63, 9, 37, 40, 22, 13, 83, 95, 81, 94, 41, 52, 6};        //list of 500 integers between 0 and 1000        int[] temp4 = {607, 776, 38, 797, 290, 84, 539, 397, 208, 604, 429, 698, 215, 917, 751, 156, 830, 829, 368, 979,                225, 705, 481, 715, 978, 77, 741, 44, 126, 254, 354, 352, 550, 667, 317, 800, 142, 836, 380, 842, 240, 389,                443, 449, 201, 639, 346, 813, 560, 448, 834, 730, 824, 595, 645, 412, 581, 856, 736, 552, 926, 860, 54, 492, 97, 654, 22, 110, 507, 310, 588, 282, 56, 277, 728, 656, 908, 795, 6, 360, 722, 636, 633, 764, 931, 23, 421, 190, 470, 953, 707, 246, 942, 411, 782, 180, 300, 524, 805, 872, 295, 162, 733, 814, 224, 117, 742, 276, 675, 29, 542, 652, 711, 238, 206, 433, 286, 327, 547, 761, 221, 820, 613, 591, 522, 745, 420, 25, 677, 672, 275, 913, 408, 242, 969, 331, 709, 485, 727, 638, 119, 232, 393, 134, 620, 382, 699, 324, 618, 586, 20, 263, 907, 472, 658, 139, 749, 463, 212, 619, 105, 822, 332, 71, 217, 370, 182, 609, 695, 854, 521, 252, 598, 14, 222, 3, 39, 63, 245, 17, 279, 2, 772, 960, 48, 428, 862, 655, 641, 100, 684, 930, 845, 567, 788, 689, 375, 27, 617, 503, 518, 794, 700, 152, 278, 231, 622, 517, 770, 540, 166, 956, 923, 871, 268, 893, 241, 697, 673, 179, 396, 696, 41, 778, 626, 877, 804, 243, 89, 580, 214, 223, 631, 112, 488, 309, 478, 721, 482, 674, 997, 121, 832, 528, 124, 562, 493, 49, 806, 676, 338, 763, 704, 972, 605, 502, 563, 898, 693, 600, 859, 376, 127, 313, 266, 831, 487, 933, 784, 99, 28, 732, 779, 294, 533, 683, 576, 999, 400, 508, 879, 900, 271, 612, 151, 308, 454, 892, 912, 78, 273, 630, 145, 76, 774, 851, 320, 102, 678, 10, 355, 880, 111, 681, 666, 572, 140, 970, 702, 840, 783, 737, 68, 115, 359, 261, 629, 941, 574, 724, 233, 292, 650, 314, 205, 384, 66, 417, 789, 98, 530, 459, 585, 128, 520, 118, 176, 194, 132, 936, 153, 855, 94, 131, 838, 594, 828, 601, 318, 15, 691, 248, 987, 293, 849, 330, 33, 226, 692, 948, 985, 52, 559, 236, 5, 72, 706, 402, 334, 322, 284, 62, 944, 383, 283, 843, 593, 589, 415, 549, 710, 846, 512, 147, 986, 940, 431, 88, 687, 980, 685, 305, 432, 553, 916, 895, 558, 726, 219, 297, 946, 473, 896, 943, 125, 109, 120, 932, 971, 865, 743, 615, 811, 802, 47, 307, 7, 858, 919, 747, 172, 875, 452, 291, 536, 890, 719, 474, 653, 848, 210, 386, 734, 171, 963, 464, 990, 58, 883, 928, 426, 817, 708, 679, 568, 164, 446, 713, 424, 343, 483, 686, 825, 566, 92, 513, 847, 26, 184, 611, 167, 361, 515, 216, 818, 541, 950, 435, 897, 12, 69, 87, 965, 504, 471, 793, 479, 192, 304, 239, 808, 257, 750, 819, 592, 501, 701, 438, 777, 807, 398, 113, 299, 516, 419, 537, 981, 494, 247, 927};        //list of 1000 integers between 0 and 2000        int[] temp6 = {27, 1682, 244, 874, 139, 713, 1996, 1398, 391, 1026, 6, 1092, 817, 1660, 36, 1465, 2000, 915, 879, 380, 191, 857, 850, 1534, 1065, 1496, 412, 403, 725, 76, 1791, 802, 443, 140, 880, 265, 960, 155, 1509, 1343, 964, 224, 58, 367, 1694, 1021, 752, 1978, 1429, 956, 413, 1774, 1605, 386, 1745, 1441, 439, 1601, 1755, 1243, 782, 1665, 267, 700, 783, 1627, 423, 1460, 1985, 1234, 64, 526, 158, 630, 831, 33, 474, 1035, 1595, 1334, 1365, 306, 1506, 470, 689, 923, 1335, 327, 766, 753, 1888, 1074, 598, 1557, 1090, 1671, 303, 1581, 1448, 223, 1008, 1722, 166, 1376, 508, 16, 1379, 318, 378, 604, 627, 893, 8, 387, 1124, 846, 432, 708, 1143, 1104, 1203, 1476, 149, 320, 1462, 1358, 1965, 1327, 217, 1427, 1166, 111, 1350, 1771, 245, 887, 344, 1450, 1964, 5, 1687, 181, 153, 1490, 1866, 525, 1872, 1949, 541, 692, 959, 672, 492, 258, 920, 1742, 569, 431, 550, 632, 1013, 1573, 602, 871, 294, 576, 1511, 1483, 1333, 354, 787, 1887, 1407, 981, 62, 1493, 491, 980, 1303, 1854, 983, 1788, 499, 1396, 1278, 81, 693, 1984, 48, 845, 562, 161, 628, 716, 993, 1301, 1915, 434, 1824, 1702, 702, 1844, 1537, 207, 1389, 293, 527, 1739, 1898, 1559, 1768, 1170, 592, 875, 1069, 1513, 674, 463, 1877, 1091, 806, 283, 548, 393, 1071, 137, 202, 603, 145, 1019, 1812, 1214, 1488, 1925, 351, 646, 1738, 1017, 510, 1942, 638, 330, 237, 1022, 322, 769, 193, 1206, 881, 584, 520, 256, 1873, 1157, 1533, 1326, 834, 339, 1882, 175, 1468, 953, 1154, 1043, 681, 250, 1467, 1837, 12, 1590, 1784, 96, 1524, 1371, 1656, 1507, 560, 1314, 46, 1031, 675, 1158, 1611, 171, 804, 530, 1284, 1147, 136, 198, 435, 1282, 275, 1085, 142, 1827, 788, 1997, 184, 1554, 1767, 251, 614, 1395, 468, 266, 1050, 894, 134, 66, 1497, 1779, 1117, 690, 82, 952, 1409, 611, 971, 1546, 1536, 709, 1087, 1319, 233, 1640, 1202, 1489, 934, 624, 1631, 891, 515, 750, 1683, 1455, 539, 1715, 1673, 1442, 1083, 1237, 86, 1980, 68, 969, 1724, 1018, 1051, 842, 1572, 495, 640, 1658, 1322, 916, 195, 976, 1425, 1160, 1901, 1852, 1959, 1359, 1096, 1075, 1618, 1318, 1443, 156, 832, 25, 1183, 108, 1625, 105, 262, 1195, 399, 445, 1068, 564, 553, 54, 1639, 1240, 1058, 260, 1961, 1867, 865, 388, 10, 652, 419, 220, 1626, 585, 872, 705, 32, 841, 1815, 1835, 1340, 644, 480, 1578, 43, 1855, 1325, 984, 957, 1401, 336, 1063, 128, 13, 647, 74, 1874, 654, 246, 1252, 1125, 421, 843, 574, 1247, 1231, 449, 1042, 862, 1108, 522, 1553, 309, 1672, 11, 1947, 568, 1351, 1661, 743, 1923, 1473, 1295, 1141, 1165, 742, 1899, 1029, 749, 648, 1757, 420, 228, 933, 292, 636, 844, 684, 1983, 552, 558, 505, 1233, 1150, 56, 943, 1357, 1300, 352, 970, 1392, 484, 1242, 828, 1266, 1079, 1020, 1832, 1523, 1990, 1262, 1637, 18, 1011, 34, 1792, 546, 1542, 1962, 1352, 1328, 1754, 112, 1893, 1567, 1200, 225, 639, 478, 616, 1818, 651, 1135, 764, 1491, 1267, 452, 407, 425, 1144, 469, 343, 1103, 209, 264, 1918, 1086, 118, 727, 963, 622, 1119, 1828, 1929, 760, 1603, 1137, 643, 990, 1933, 450, 9, 667, 676, 1560, 1109, 591, 554, 1454, 918, 889, 1302, 1226, 1892, 109, 1081, 375, 1215, 1916, 248, 466, 365, 1471, 822, 117, 441, 1633, 899, 1361, 1464, 1061, 1676, 979, 144, 892, 255, 995, 1346, 665, 848, 773, 1968, 1870, 1289, 1129, 551, 279, 1928, 904, 737, 1998, 1484, 180, 348, 1059, 668, 1115, 1151, 1753, 1589, 1268, 1910, 789, 346, 1693, 1765, 1212, 214, 1159, 200, 355, 1449, 1093, 1435, 277, 1610, 1748, 213, 516, 1309, 746, 1189, 1163, 1762, 1641, 1744, 1227, 534, 1698, 657, 1193, 70, 1142, 1097, 1908, 1388, 227, 49, 987, 1710, 1993, 52, 447, 1459, 563, 31, 1945, 1456, 1232, 994, 707, 88, 1161, 430, 1777, 7, 100, 456, 1591, 1805, 4, 212, 385, 721, 883, 50, 1668, 163, 263, 185, 203, 1841, 486, 204, 1850, 23, 1260, 168, 940, 1479, 146, 1136, 360, 1130, 1521, 882, 683, 679, 390, 1703, 414, 629, 398, 273, 141, 1288, 1257, 1258, 1692, 472, 1181, 1290, 673, 97, 1368, 77, 907, 1400, 1561, 415, 1434, 506, 1120, 1969, 1131, 384, 1688, 939, 1697, 1686, 623, 906, 1180, 1876, 1390, 406, 1865, 1986, 1446, 996, 401, 1750, 1538, 754, 866, 1049, 1582, 1569, 465, 999, 1544, 809, 1648, 1617, 1643, 1045, 1298, 1979, 968, 1790, 793, 1550, 1875, 230, 503, 1517, 1349, 1287, 631, 126, 1414, 1783, 973, 1228, 1740, 1796, 1650, 1501, 67, 433, 557, 1010, 1463, 575, 38, 1007, 417, 1970, 1732, 518, 580, 169, 1291, 937, 1789, 1909, 931, 1421, 1457, 1453, 1452, 890, 501, 1853, 1138, 1387, 606, 756, 1040, 1519, 59, 779, 1614, 313, 1046, 1944, 910, 1649, 1190, 1378, 1277, 1354, 1270, 1084, 319, 1279, 494, 1756, 531, 650, 1842, 148, 669, 1967, 1095, 740, 596, 190, 366, 785, 440, 1669, 416, 829, 524, 317, 1564, 1064, 838, 664, 694, 1951, 276, 538, 1763, 1015, 924, 577, 1406, 1663, 497, 405, 1259, 1470, 837, 159, 914, 854, 229, 1229, 1849, 1052, 601, 1644, 1833, 621, 517, 1802, 637, 827, 1187, 634, 521, 661, 821, 1725, 254, 1927, 1720, 935, 123, 1808, 69, 1786, 377, 1210, 1355, 1344, 759, 1914, 453, 428, 1602, 851, 1263, 858, 409, 1868, 820, 1444, 1604, 1520, 1905, 1701, 1505, 1030, 666, 1813, 400, 125, 496, 290, 1935, 1167, 1735, 1341, 177, 1900, 781, 173, 719, 162, 231, 587, 1329, 1737, 807, 1704, 772, 812, 350, 1162, 1616, 1053, 252, 1208, 810, 1169, 1225, 1721, 1707, 1563, 1175, 912, 87, 1840, 662, 688, 1836, 549, 93, 73, 701, 1896, 1716, 529, 113, 1571, 1845, 1670, 722, 334, 116, 1324, 1499, 382, 483, 1912, 1048, 1588, 593, 1848, 919, 590, 761, 1532, 402, 1403, 1276, 799, 1543, 1500, 1055, 122, 1966, 946, 1804, 718,                852, 1579, 1883, 110, 368, 777, 985, 572, 347, 1592, 612, 488, 1719, 115, 487, 1495, 877, 1863};        return temp6;    }    public static void printList(int[] list) {        if (list == null) return;        System.out.println();        for (int number : list                ) {            System.out.print(number + " ");        }    }    //Takes O(n) in space and O(n^2) in time.    //Most Intuitive sorting algorithms    public static int[] selectionSortExtraMemory(int[] list, int listSize) {        int sortedIndex = 0, lowestIndex = 0;        int temp = LARGE_VALUE;        int[] sortedList = new int[listSize];        while (sortedIndex < listSize) {//sortedList is not Full            //find minimum number form unsorted list            for (int i = 0; i < listSize; i++) {                if (list[i] < temp) {                    lowestIndex = i;                    temp = list[i];                }            }            //copy it to sorted list            list[lowestIndex] = LARGE_VALUE;            sortedList[sortedIndex++] = temp;            temp = LARGE_VALUE;        }        return sortedList;    }    //Takes O(1) in space [ constant space complexity )    //Takes O(n^2) in time    public static int[] selectionSortWithoutExtraMemory(int[] list, int listSize) {        int sortedIndex = 0, lowestIndex = 0;        int temp = LARGE_VALUE;        while (sortedIndex < listSize) {//sortedList is not Full            //find minimun number form unsorted list            for (int i = sortedIndex; i < listSize; i++) {                if (list[i] < temp) {                    lowestIndex = i;                    temp = list[i];                }            }            //swap lowest element with first element of the unsorted part of the same list.            // Increment the index of sorted part after swap            list[lowestIndex] = list[sortedIndex];            list[sortedIndex++] = temp;            temp = LARGE_VALUE;        }        return list;    }    //Takes O(1) in space [ constant space complexity )    //Takes O(n^2) in time in worst and average case. O(n) in best case    public static int[] bubbleSort(int[] list, int listSize) {        int temp;        boolean sortedListFlag;        //conduct (listsize-1) passes on the list        for (int i = 0; i < listSize; i++) {            sortedListFlag = true;            //check if element to the right is less than current number and keep swapping            //this creates a sorted list on the right side of the list by adding one element in each iteration            //on each iteration of the loop we can skip traversing the sorted part of the list            //hence we go from first element to the last element of the unsorted part only            for (int j = 0; j < listSize - 1 - i; j++) {                if (list[j] > list[j + 1]) { //swap the elements                    temp = list[j];                    list[j] = list[j + 1];                    list[j + 1] = temp;                    sortedListFlag = false; // this tells us that swapping has taken place, hence list is not in order                }            }            if (sortedListFlag == true)                break; // if swapping never took place in an iteration it implies list is sorted.            // Hence we break from the loop        }        return list;    }    //Takes O(1) in space [ constant space complexity )    //Takes O(n^2) in time in worst and average time. O(n) in best case    public static int[] insertionSort(int[] list, int listSize) {        int temp, numberToBeInserted;        for (int i = 1; i < listSize; i++) {            int holeIndex = i;            numberToBeInserted = list[holeIndex];            //shift all the numbers greater than the "numberToBeInserted" to the right.            while (holeIndex > 0 && numberToBeInserted < list[holeIndex - 1]) {                list[holeIndex] = list[holeIndex - 1];                holeIndex--;            }            //insert the number at its place            list[holeIndex] = numberToBeInserted;        }        return list;    }    public static void mergeSort(int[] list, int listSize) {        //keep dividing until problem reduced to single elements        if (listSize > 1) {            // divide the list into two parts            // sort the two lists            // merge the two halves            int[] leftlist = new int[listSize / 2];            int[] rightList = new int[listSize - listSize / 2];            for (int i = 0; i < listSize / 2; i++) leftlist[i] = list[i];            for (int i = listSize / 2; i < listSize; i++) rightList[i - listSize / 2] = list[i];            mergeSort(leftlist, leftlist.length);            mergeSort(rightList, rightList.length);            merge(leftlist, rightList, list);        }        return ;    }    public static void merge(int[] leftSortedList, int[] rightSortedList, int[] originalUnsortedList) {        int leftIndex = 0, rightIndex = 0, mergedIndex = 0;        int leftListSize = leftSortedList.length, rightListSize = rightSortedList.length;        while (leftIndex < leftListSize && rightIndex < rightListSize) {            if (leftSortedList[leftIndex] < rightSortedList[rightIndex])                originalUnsortedList[mergedIndex++] = leftSortedList[leftIndex++];            else                originalUnsortedList[mergedIndex++] = rightSortedList[rightIndex++];        }        while (leftIndex < leftListSize) originalUnsortedList[mergedIndex++] = leftSortedList[leftIndex++];        while (rightIndex < rightListSize) originalUnsortedList[mergedIndex++] = rightSortedList[rightIndex++];        return ;    }    public static void quickSort( int[] list, int start, int end){        //Generate a pivot        //move elements greater than pivot to its right and those less than the pivot to its left        //Recursively continue the process until a single element list is created        //System.out.println("\nstart :" + start + "  end :" + end );        //printList(list);        if (start < end ) {            int pivotIndex = partitionList(list,start,end);            quickSort(list,0,pivotIndex-1);            quickSort(list,pivotIndex+1, end);        }        return ;    }    public static int partitionList( int[] list,int start, int end){        int pivotcursor = start,temp;        int pivotElement = list[end];        for (int i = start; i <= end-1 ; i++) {            if( list[i] <= pivotElement){                temp = list[i];                list[i] = list[pivotcursor];                list[pivotcursor] =temp;                pivotcursor++;            }        }        temp = list[pivotcursor];        list[pivotcursor] = list[end];        list[end] = temp;        return pivotcursor;    }    static int partition(int arr[], int left, int right) {        int i = left, j = right;        int tmp;        int pivot = arr[(left + right) / 2];        while (i <= j) {            while (arr[i] < pivot)                i++;            while (arr[j] > pivot)                j--;            if (i <= j) {                tmp = arr[i];                arr[i++] = arr[j];                arr[j--] = tmp;            }        };        return i;    }    static void quickSort2(int arr[], int left, int right) {        int index = partition(arr, left, right);        if (left < index - 1)            quickSort(arr, left, index - 1);        if (index < right)            quickSort(arr, index, right);    }    public static void randomisedQuickSort( int[] list, int start, int end){        //Generate a pivot        //move elements greater than pivot to its right and those less than the pivot to its left        //Recursively continue the process until a single element list is created        //System.out.println("\nstart :" + start + "  end :" + end );        //printList(list);        if (start < end ) {            int pivotIndex = randomisedPartition(list,start,end);            quickSort(list,0,pivotIndex-1);            quickSort(list,pivotIndex+1, end);        }        return ;    }    public static int randomisedPartition (int[] list,int start, int end){        int pivot = (new Random()).nextInt(end - start +1 ) + start, temp;        temp = list[pivot];        list[pivot] = list[end];        list[end] = temp;        pivot = partitionList(list,start,end);        return pivot;    }}